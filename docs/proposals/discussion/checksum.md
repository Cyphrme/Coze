# Proposal: Checksums 

In Coze, all checksums are generated by hashing the value that the checksum is
on. Checksum's hashing algorithm must align with `alg`.  Checksums may be
truncated to any size.   

Checksums begin after the character tilde, `~`.  Checksums must not begin
strings.  

Example:
```JSON
{
"tmb":"cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk~WR_2EpmB3e6ldoPl5VFTC_09BxeumOv3XvIB55igkZg"
}
```

Which may be truncated::
"tmb":"cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk~WR_2"


# Coze three letter field name:
`chk`

# Serialized Form 
If sending the short serialized form, `isd`, `d`, `x`, `tmb` would benefit from
checksums.


## ~ as checksum delimiter
If going with the delimited option, ~ seems reasonable. 

- Not base64ut
- URL safe character.  
- Last ASCII character.  

## Option 1: Delimited.  Checksums are on the thing immediately previous to it.  

Pros
 - All things can be check summed. 
 - Allows short forms.  

Cons
 - What the delimiter? 

## (Bad) Option 2 "First class" checksums

Only only checksum tmb.

alg:::tmb:chk


# Coze and seeds
Seeds are currently not implemented in Coze.  

# How to force implicit checksumming?

 1. Should applications be required to checksum if checksumming is possible?

 2. Alternatively, checksumming could be forced only when checksum is present,
    but all components should be checked. 

 3. Alternatively, only items with checksums are checksummed.  


Option 1 is the most robust.  2 is somewhat expected.  3 is easy to code.  


## See also:
https://github.com/multiformats/multiformats
https://multiformats.io/multihash/


# Seed considerations.  
Currently, in all Coze supported signing algorithms (ES224, ES256, ES384, ES512,
Ed25519, Ed25519ph) x is directly related to d.  We plan on keeping this
assumption in place when supporting future algorithms.  

In Coze for Ed25519 and Ed25519ph, d is what the RFC names the "seed", so a
further seed isn't (necessarily) needed.

Seed probably would be implemented as a generalized way to generate a key for
any given Coze algorithm.  


# Checksum utility

For the key below, checksums are not useful because:
1. tmb is the checksum of x.
2. x may be recalculated from d, so x serves as the checksum of d.  

```JSON
{
	"alg":"ES256",
	"iat":1623132000,
	"kid":"Zami's Majuscule Key.",
	"d":"bNstg4_H3m3SlROufwRSEgibLrBuRq9114OvdapcpVA",
	"tmb":"cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk",
	"x":"2nTOaFVm2QLxmUO_SjgyscVHBtvHEfo2rq65MvgNRjORojq39Haq9rXNxvXxwba_Xj0F5vZibJR3isBdOWbo5g"
}
```


Checksums would be useful here:

```
{
	"alg":"ES256",
	"iat":1623132000,
	"kid":"Zami's Majuscule Key.",
	"tmb":"cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk",
}
```

Proposed form:
```
{
	"alg":"ES256",
	"iat":1623132000,
	"kid":"Zami's Majuscule Key.",
	"tmb":"cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk~WR_2EpmB3e6ldoPl5VFTC_09BxeumOv3XvIB55igkZg",
}
```

Serialized form and truncated to 4 characters:

``` 
ES256:cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk~WR_2
```


# Requiring Correct() calls to use any given component (`d`, `x`, `tmb`) as a checksum
Applications should just do this by default, imho.  

