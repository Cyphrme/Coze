# Proposal: Checksums and Truncatable Thumbprints

Before considering checksums, consider using `sig` as an integrity check via
cryptographic verification.  This precludes most utility of secondary checksums.  

## Checksums

In Coze, all checksums are generated by hashing the value that the checksum is
on. Checksum's hashing algorithm must align with `alg`.  Checksums may be
truncated to any size.   

Checksums begin after the character tilde, `~`.  Checksums must not begin
strings.  

Example:
```JSON
{
  "tmb":"cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk~WR_2EpmB3e6ldoPl5VFTC_09BxeumOv3XvIB55igkZg"
}
```

Which may be truncated:

```JSON
{
  "tmb":"cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk~WR_2"
}
```

## Truncatable Thumbprints
Thumbprint is truncated at `~`

```json
{
  "tmb":"cLj8vs~"
}
```

Serialized form:
```
alg:d::cLj8vs~
```

### ~ as checksum delimiter
If going with the delimited option, ~ seems reasonable. 

- Not base64ut
- URL safe character.  
- Last ASCII character.  


## Cryptographic considerations

`x` and `d` may leak cryptographic information, and so user may not want to
disclose them under certain circumstances.  Since `tmb` is a digest, it may
always be used as a checksum.  


## Checksum Coze three letter field name
Currently, this isn't needed, but if it ever were, this would be the three
letter field name.

Checksum field name: `chk`


## Seed considerations.  
Currently, Coze assumes that `x` is derived from `d`.  In all Coze supported
signing algorithms (ES224, ES256, ES384, ES512, Ed25519, Ed25519ph) x is
directly related to d.  We plan on keeping this assumption in place when
supporting future algorithms.  

In Coze for Ed25519 and Ed25519ph, d is what the RFC names the "seed", so a
further seed isn't (necessarily) needed.

Seed probably would be implemented as a generalized way to generate a key for
any given Coze algorithm.  



# Checksum utility

For the key below, checksums are not useful because:
1. tmb is the checksum of x.
2. x may be recalculated from d, so x serves as the checksum of d.  

```JSON
{
	"alg":"ES256",
	"iat":1623132000,
	"kid":"Zami's Majuscule Key.",
	"d":"bNstg4_H3m3SlROufwRSEgibLrBuRq9114OvdapcpVA",
	"tmb":"cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk",
	"x":"2nTOaFVm2QLxmUO_SjgyscVHBtvHEfo2rq65MvgNRjORojq39Haq9rXNxvXxwba_Xj0F5vZibJR3isBdOWbo5g"
}
```

Checksums would be useful here:

```
{
	"alg":"ES256",
	"iat":1623132000,
	"kid":"Zami's Majuscule Key.",
	"tmb":"cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk",
}
```

Proposed form:
```
{
	"alg":"ES256",
	"iat":1623132000,
	"kid":"Zami's Majuscule Key.",
	"tmb":"cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk~WR_2EpmB3e6ldoPl5VFTC_09BxeumOv3XvIB55igkZg",
}
```

Serialized form and truncated to 4 characters:

``` 
ES256:cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk~WR_2
```


## Serialized Form 
If sending the short serialized form, `izd`, `d`, `x`, `tmb` would benefit from
checksums.

### Useful
These are the only forms that `chk` is useful.  All other forms are redundant.  

```
alg:izd~chk:::
alg:d~chk::
alg:x~chk:
alg:tmb~chk
```

### Redundant (don't do this)
Any combination of two or more Coze fields [`izd`,`d`,`x`,`tmb`], including the following:

- `alg:x:tmb~chk`
    - tmb already serves as the checksum of x.  
- `alg:d~chk:x:`
   - x is derived from d and so x may serve as a checksum.    
- `alg:d~chk::tmb`
    - tmb is derived from x, which x is derived from d and so tmb may serve as a checksum for d.
- `alg:d~chk::tmb~chk`
- `alg:d~chk:x~chk:`
- `alg:d~chk:x~chk:tmb~chk` 
- `alg:izd~chk:d~chk:x~chk:tmb~chk` 

The only reason to do these forms is if your system does not have the ability to
do signatures, but does have the ability to check digests.  This would be a
mostly unreasonable circumstance.  


# Requiring Correct() calls to use any given component (`d`, `x`, `tmb`) as a checksum
Applications should just do this by default, imho.  

Alternatively:

 1. Should applications be required to checksum if checksumming is possible?

 2. Alternatively, checksumming could be forced only when checksum is present,
    but all components should be checked. 

 3. Alternatively, only items with checksums are checksummed.  

Option 1 is the most robust.  2 is somewhat expected.  3 is easy to code.  



## See also:
https://github.com/multiformats/multiformats
https://multiformats.io/multihash/
